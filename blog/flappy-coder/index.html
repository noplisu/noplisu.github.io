<html>
  <head>
    <meta charset="utf8" />
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <link rel="stylesheet" type="text/css" href="css/cv.css">
    <link rel="stylesheet" type="text/css" href="css/navbar.css">
    <link rel="stylesheet" type="text/css" href="../css/codestyles.css">
    <link rel="shortcut icon" href="TemplateData/favicon.ico" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
    <script src="TemplateData/UnityProgress.js"></script>
    <title>Flappy coder tutorial</title>
  </head>
  <body>
    <div class='container'>
      <article>
        <h1>Flappy coder tutorial</h1>
        <p>Flappy coder czyli jak stworzyć klon gry flappy bird w silniku Unity3D.</p>
        <h2>Założenia</h2>
        <p>W tej części zapoznamy się z podstawowymi założeniami naszego projektu.</p>
        <h3>Poziom: Nowicjusz</h3>
        <h3>Tworzone funkcjonalności</h3>
        <ul>
          <li>Poruszanie gracza przy pomocy spacji</li>
          <li>Poruszanie gracza w przód</li>
          <li>Kamera śledząca gracza</li>
          <li>Przegrana przy wyjściu poza ekran</li>
          <li>Przegrana przy kolizji z przeszkodą</li>
          <li>Tworznie przeszkód</li>
          <li>Niszczenie przeszkód</li>
          <li>Dodawanie punktów</li>
          <li>Zapisywanie punktów</li>
        </ul>
        <h3>Wymagane oprogramowanie</h3>
        <ul><li>Unity3D</li></ul>
        <h2>Projekt</h2>
        <p>W tej części przejdziemy do implementacji projektu.</p>
        <h3>Tworzenie Projektu</h3>
        <p>Pierwszym krokiem w tworzeniu gry jest utworzenie projektu.</p>
        <img src='images/A1K1_tworzenie_projektu.png' />
        <p>Najważnieszym elementem na tym etapie jest nadanie nazwy projektu. W tym przypadku projekt będzie projektem 3D.</p>
        <h3>Ustawienie kamery</h3>
        <p>Po zaznaczeniu kamery w hierarchii w inspektorze pojawią się komponenty przypięte do danego obiektu.</p>
        <img src='images/A1K2_hierarchia_kamera.png' />
        <p>W komponencie transform zmieniamy pozycje kamery na: 0, 0, -10. Następnie zmieniamy ustawienia komponentu camera z projection: perspective na projection: ortographic.</p>
        <img src='images/A1K2_kamera_inspektor.png' />
        <p>Dzięki tym zmianom nasza kamera będzie na wprost linii 0 co ułatwi ustawianie obiektów, zmiana projekcji nada odpowiedni ton graficzny naszej grze.</p>
        <img src='images/projection_types.png' />
        <h3>Dodanie gracza</h3>
        <p>Graczem w naszej grze będzie sfera. Aby ją dodać klikamy zakładkę <i>GameObject->3D Object->Sphere</i>. Następnie naszą kulę ustawimy po lewej stronie ekranu w tym celu zaznaczamy ją w hierarchii po czym w inspektorze zmieniamy pozycje w komponencie transform na: -6, 3, 0.</p>
        <p>Gracz będzie się poruszał a więc aby poinformować o tym silnik należy dodać do naszej sfery komponent <i>rigidbody</i>. W tym celu zaznaczamy nasz obiekt w hierarchii następnie u dołu inspektora klikamy <i>Add Component->Physics->Rigidbody</i>. Wiemy, że gracz poruszać się będzie ze stałą prędkością w osi x oraz opadać i wznosić się w osi y, nie jest jednak wymagane aby poruszał się on w osi z ani nie jest wymagana żadna rotacja tego obiektu w związku z tym ograniczymy ruch gracza przy pomocy constraints componentu rigidbody.</p>
        <img src='images/sphere_inspektor.png' />
        <p>W celu łatwiejszego odnalezienia gracza w hierarchii zmienimy jego nazwe na <i>Player</i> aby to zrobić zaznaczamy obiekt gracza następnie zmieniamy jego nazwę u góry inspektora z Sphere na Player. W celu łatwiejszej identyfikacji gracza w kodzie nadamy mu też tag Player, nadawanie tagu znajduje się poniżej zmiany nazwy.</p>
        <h3>Poruszanie gracza</h3>
        <p>Gracz w naszej grze będzie poruszany wyłącznie przy pomocy przycisku spacja który spowoduje wzniesienie się sfery w tym celu przygotujemy skrypt Move.cs. Aby utworzyć nowy skrypt klikamy prawym przyciskiem myszy w częsci Assets okna Project następnie klikamy <i>Create->C#</i> Script i nadajemy mu nazwę <code>PlayerMovement</code></p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;PlayerMovement&nbsp;:&nbsp;MonoBehaviour&nbsp;{<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;jumpForce&nbsp;=&nbsp;350;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;Rigidbody&nbsp;rigid;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Use&nbsp;this&nbsp;for&nbsp;initialization</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Start&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid&nbsp;=&nbsp;GetComponent&lt;Rigidbody&gt;();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Update&nbsp;is&nbsp;called&nbsp;once&nbsp;per&nbsp;frame</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Update&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fly();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;fly()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(Input.GetKeyDown(KeyCode.Space))&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.velocity&nbsp;=&nbsp;Vector3.zero;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.AddForce(Vector3.up&nbsp;*&nbsp;jumpForce);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <p>W skrypcie tym tworzymy publiczną zmienną <code>jumpForce</code> typu <code>float</code> o wstępnej wartości 350. Ustawienie tej zmiennej jako publicznej pozwoli nam na zmiane tej wartości w inspektorze obiektu do którego podepnięty zostanie ten skrypt. Do skryptu dopisujemy też zmienną rigid typu <i>Rigidbody</i>. Metody <code>Start</code> oraz <code>Update</code> są to zmienne wykorzystywane przez klase <code>MonoBehaviour</code> i są wywoływane w odpowiednich momentach cyklu życia aplikacji. Metoda <code>Start</code> wywoływana jest wyłącznie jeden raz przy tworzeniu obiektu. Metoda <code>Update</code> wywoływana jest co klatke działania aplikacji. Są to tylko dwie z wielu metod w cyklu życia aplikacji silnika unity.</p>
        <img src="images/monobehaviour_flowchart.svg" />
        <p>Wewnątrz metody <code>Start</code> pobieramy komponent <i>Rigidbody</i> przypięty do obiektu. Wewnątrz metody <code>Update</code> wywołujemy metodę <code>fly</code>. Metoda <code>fly</code> sprawdza czy w danej klatce naciśnięty został przycisk spacja, jeżeli został to ustawia aktualną prędkość z jaką porusza się obiekt na 0 a następnie dokłada siłę która porusza obiekt do góry.</p>
        <h3>Poruszanie gracza (część 2)</h3>
        <p>Nasz gracz musi poruszać się też do przodu w tym celu do klasy <code>PlayerMovement</code> dopisujemy publiczną zmienną <code>speed</code> oraz metode <code>move</code>, będzie ona dodawać ruch w prawą stronę z ustaloną prędkością. Następnie wywołujemy tą metodę w metodzie <code>Update</code>.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;PlayerMovement&nbsp;:&nbsp;MonoBehaviour&nbsp;{<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;jumpForce&nbsp;=&nbsp;350;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;speed&nbsp;=&nbsp;3;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;Rigidbody&nbsp;rigid;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Use&nbsp;this&nbsp;for&nbsp;initialization</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Start&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid&nbsp;=&nbsp;GetComponent&lt;Rigidbody&gt;();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Update&nbsp;is&nbsp;called&nbsp;once&nbsp;per&nbsp;frame</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Update&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fly();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;fly()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(Input.GetKeyDown(KeyCode.Space))&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.velocity&nbsp;=&nbsp;Vector3.zero;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.AddForce(Vector3.up&nbsp;*&nbsp;jumpForce);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;move()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;velocity&nbsp;=&nbsp;rigid.velocity;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;velocity.x&nbsp;=&nbsp;speed;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.velocity&nbsp;=&nbsp;velocity;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <p>Skrypt ten podpinamy pod obiekt <i>Player</i> przeciągając skrypt z zakładki assets na obiekt <i>Player</i> w hierarchii.</p>
        <h3>Kamera śledząca gracza</h3>
        <p>Kolejną funkcjonalnością jest skrypt który sprawi, że kamera będzie podążała za graczem. w tym celu tworzymy nowy skrypt klikając w <i>project->assets</i> prawym przyciskiem myszy i klikajac <i>create->C#</i> script. Skrypt ten nazywamy <code>CameraMovement</code>. W skrypcie tym deklarujemy publiczną zmienną typu <code>Transform</code> o nazwie <code>followObject</code> oraz prywatną zmienną typu <code>Vector3</code> o nazwie distance. W metodzie <code>Start</code> obliczamy dystans jako różnice aktualnej pozycji kamery i pozycji <code>followObject</code>. W metodzie <code>Update</code> zmieniamy składową x pozycji kamery aby utrzymywała stałą odległość od obiektu.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;CameraMove&nbsp;:&nbsp;MonoBehaviour<br />
        {<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;Transform&nbsp;followObject;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;distance;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Start()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distance&nbsp;=&nbsp;transform.position&nbsp;-&nbsp;followObject.position;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Update()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;position&nbsp;=&nbsp;transform.position;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position.x&nbsp;=&nbsp;followObject.position.x&nbsp;+&nbsp;distance.x;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transform.position&nbsp;=&nbsp;position;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <p>Skrypt ten należy podpiąć pod obiekt <i>Main Camera</i>, a następnie z hierarchii do inspektora należy przeciągnąć obiekt gracza do componentu <i>Camera Move</i>.</p>
        <img src="images/camera_move.png" />
        <h3>Restart gry gdy gracz trafi za mapę</h3>
        <p>Następną funkcjonalnością jest przegrana w momencie w którym gracz opuści planszę z dołu lub góry. W tym celu do skryptu <code>PlayerMovement</code> dopisujemy metodę dead która restartuje gre przy wywołaniu oraz metodę <code>outOfCamera</code> która sprawdza czy obiekt do ktorego podpięty jest skrypt nie opuścił widoku z dołu lub góry kamery oznaczonej tagiem <i>MainCamera</i> i jeżli to zrobił to wywołuje on metodę <code>dead</code>. Metodę <code>outOfCamera</code> wywołujemy jako pierwszą instrukcję metody <code>Update</code>.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine.SceneManagement;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;PlayerMovement&nbsp;:&nbsp;MonoBehaviour&nbsp;{<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;jumpForce&nbsp;=&nbsp;350;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;speed&nbsp;=&nbsp;3;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;Rigidbody&nbsp;rigid;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Use&nbsp;this&nbsp;for&nbsp;initialization</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Start&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid&nbsp;=&nbsp;GetComponent&lt;Rigidbody&gt;();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Update&nbsp;is&nbsp;called&nbsp;once&nbsp;per&nbsp;frame</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Update&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outOfCamera();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fly();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;fly()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(Input.GetKeyDown(KeyCode.Space))&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.velocity&nbsp;=&nbsp;Vector3.zero;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.AddForce(Vector3.up&nbsp;*&nbsp;jumpForce);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;move()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;velocity&nbsp;=&nbsp;rigid.velocity;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;velocity.x&nbsp;=&nbsp;speed;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.velocity&nbsp;=&nbsp;velocity;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;dead()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;outOfCamera()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;viewPos&nbsp;=&nbsp;Camera.main.WorldToViewportPoint(transform.position);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(viewPos.y&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;viewPos.y&nbsp;&gt;&nbsp;1)&nbsp;{&nbsp;dead();&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <h3>Utworzenie przeszkody</h3>
        <p>Bazą naszej przeszkody będzie pusty <i>Game Object</i> któremy nadajemy nazwę <i>Gap</i>. Temu <i>Game Object</i> należy zmienić pozycję na: 3, 0, 0. Następnie klikamy ten obiekt prawym przyciskiem myszy i klikamy <i>3D Object->Cube</i>, w ten sposób tworzymy 2 cube będące dziećmi <i>Game Object Gap</i>. Pierwszy z tych cube należy nazwać <i>Upper</i> i nadać mu pozycję: 0, 5, 0 oraz skalę: 1, 10, 1. Natomiast drugi cube należy nazwać <i>Lower</i> i nadać mu pozycję: 0, -5, 0 oraz skalę: 1, 10, 1. Tak przygotowanej przeszkodzie chcemy losowo nadawać wysokość oraz rozmiar szczeliny w tym celu podpinamy pod <i>Gap</i> skrypt który nazwiemy <code>RandomizeGap</code>. Skrypt ten będzie posiadał dwie publiczne zmienne typu <code>Transform</code> o nazwach <code>upper</code> i <code>lower</code>, 4 publiczne zmienne typu <code>float</code> o nazwach <code>minOffset</code>, <code>maxOffset</code>, które będą odpowiadać za wysokość szczeliny oraz zmienne <code>minGap</code> oraz <code>maxGap</code> które będą odpowiadać za wielkość szczeliny. Skrypt ten posiada wyłącznie metodę <code>Awake</code> która losuje ostateczną wysokość oraz wielkość szczeliny a następnie przesuwa obiekty <i>upper</i> i <i>lower</i> tak aby utworzyły szczelinę.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;RandomizeGap&nbsp;:&nbsp;MonoBehaviour<br />
        {<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;Transform&nbsp;upper;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;Transform&nbsp;lower;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;minOffset&nbsp;=&nbsp;-3;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;maxOffset&nbsp;=&nbsp;3;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;minGap&nbsp;=&nbsp;2;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;maxGap&nbsp;=&nbsp;4;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Awake()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">float</span>&nbsp;offset&nbsp;=&nbsp;Random.Range(minOffset,&nbsp;maxOffset);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">float</span>&nbsp;gap&nbsp;=&nbsp;Random.Range(minGap,&nbsp;maxGap);<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;upperPosition&nbsp;=&nbsp;upper.position;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;upperPosition.y&nbsp;=&nbsp;upper.position.y&nbsp;+&nbsp;offset&nbsp;+&nbsp;gap;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;upper.position&nbsp;=&nbsp;upperPosition;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;lowerPosition&nbsp;=&nbsp;lower.position;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lowerPosition.y&nbsp;=&nbsp;lower.position.y&nbsp;+&nbsp;offset&nbsp;-&nbsp;gap;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lower.position&nbsp;=&nbsp;lowerPosition;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <p>Mając podpięty skrypt należy jeszcze przekazać mu <i>upper</i> i <i>lower</i> przeciągając je z hierarchii w odpowiednie pola inspektora.</p>
        <img src="images/randomize_gap.png" />
        <h3>Restart gry przy kolizji z przeszkodą</h3>
        <p>Aby dodać restart rozgrywki przy kolizji z przeszkodą zmieniamy skrypt <code>PlayerMovement</code> dodając do niego metodę <code>OnCollisionEnter</code> wywołującą metodę <code>dead</code>.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine.SceneManagement;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;PlayerMovement&nbsp;:&nbsp;MonoBehaviour&nbsp;{<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;jumpForce&nbsp;=&nbsp;350;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;speed&nbsp;=&nbsp;3;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;Rigidbody&nbsp;rigid;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Use&nbsp;this&nbsp;for&nbsp;initialization</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Start&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid&nbsp;=&nbsp;GetComponent&lt;Rigidbody&gt;();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Update&nbsp;is&nbsp;called&nbsp;once&nbsp;per&nbsp;frame</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Update&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outOfCamera();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fly();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;OnCollisionEnter(Collision&nbsp;collision)&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dead();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;fly()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(Input.GetKeyDown(KeyCode.Space))&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.velocity&nbsp;=&nbsp;Vector3.zero;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.AddForce(Vector3.up&nbsp;*&nbsp;jumpForce);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;move()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;velocity&nbsp;=&nbsp;rigid.velocity;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;velocity.x&nbsp;=&nbsp;speed;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rigid.velocity&nbsp;=&nbsp;velocity;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;dead()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;outOfCamera()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;viewPos&nbsp;=&nbsp;Camera.main.WorldToViewportPoint(transform.position);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(viewPos.y&nbsp;&lt;&nbsp;0&nbsp;||&nbsp;viewPos.y&nbsp;&gt;&nbsp;1)&nbsp;{&nbsp;dead();&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <h3>Proceduralne generowanie przeszkód</h3>
        <p>Aby móc proceduralnie dodawać przeszkody pierwszym krokiem będzie zapisanie naszego <i>Gap</i> w postaci pliku <i>(Prefabrykantu)</i> aby to zrobić przeciągamy <i>Gap</i> z hierarchii do okna project. Nasępnie przechodzimy do tworzenia skryptu <code>AddGaps</code> który podpinamy pod <i>MainCamera</i>. Skrypt ten będzie w regularnych odstępach czasu tworzył podany mu prefabrykant. W tym celu tworzymy publiczną zmienną typu <code>GameObject</code> o nazwie <code>gap</code>, będzie ona przechowywać nasz prefabrykant. Dodajemy też publiczną zmienną typu <code>float</code> o nazwie <code>cooldown</code> oznaczającą co ile sekund ma pojawiać się kolejna przeszkoda. Wykorzystamy też 3 zmienne prywatne. Pierwsza będzie typu <code>Camera</code> o nazwie <code>cam</code>, będzie ona przechowywać nasz komponent kamery. Druga będzie typu <code>Plane</code> oraz nazwie <code>plane</code> i przechowywać będzie płaszczyznę na której będą pojawiać się przeszkody. Trzecia będzie przechowywać <code>Vector3</code> o nazwie <code>viewportVector</code> służący do stworzenia promienia (<code>ray</code>) wyznaczającego miejsce utworzenia przeszkody. W metodzie <code>Start</code> pobieramy komponent kamery oraz inicjujemy zmienne. Następnie Wywołujemy podprogram <code>CreateGap</code>. <code>CreateGap</code> jest metodą która tworzy kolejną przeszkodę, wysyła ona promień w prawą krawędź kamery miejsce przecięcia tego promienia z wcześniej utworzoną płaszczyzną plane jest punktem w którym umieszczany jest nowy obiekt.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;AddGaps&nbsp;:&nbsp;MonoBehaviour<br />
        {<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;GameObject&nbsp;gap;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">float</span>&nbsp;cooldown&nbsp;=&nbsp;2;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;Camera&nbsp;cam;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;Plane&nbsp;plane;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;viewportVector;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Start()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cam&nbsp;=&nbsp;GetComponent&lt;Camera&gt;();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plane&nbsp;=&nbsp;<span class="Keyword">new</span>&nbsp;Plane(Vector3.back,&nbsp;Vector3.zero);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;viewportVector&nbsp;=&nbsp;<span class="Keyword">new</span>&nbsp;Vector3(1,&nbsp;0.5f,&nbsp;0);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StartCoroutine(CreateGap());<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;IEnumerator&nbsp;CreateGap()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ray&nbsp;ray&nbsp;=&nbsp;cam.ViewportPointToRay(viewportVector);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">float</span>&nbsp;distance;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plane.Raycast(ray,&nbsp;<span class="MethodParameter">out</span>&nbsp;distance);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;spawnPoint&nbsp;=&nbsp;ray.GetPoint(distance);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instantiate(gap,&nbsp;spawnPoint,&nbsp;gap.transform.rotation);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">yield</span>&nbsp;<span class="Statement">return</span>&nbsp;<span class="Keyword">new</span>&nbsp;WaitForSeconds(cooldown);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StartCoroutine(CreateGap());<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <p>Na koniec należy po komponentu przenieść z zakładki projekt prefabrykant do odpowiedniego pola inspektora w komponencie <i>Add Gaps</i>.</p>
        <h3>Czyszczenie niepotrzebnych obiektów</h3>
        <p>Niepotrzebne obiekty które opuszczą obraz kamery powinny być usuwane. W tym celu tworzymy skrypt <code>DestroyOutOfBounds</code>. Skrypt ten podpięty będzie do <i>Gap</i> i będzie on sprawdzał w metodzie <code>Update</code> czy obiekt nadal znajduje się w polu widzenia kamery jeżeli nie to jest on usuwany.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;DestroyOutOfBounds&nbsp;:&nbsp;MonoBehaviour&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Update&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outOfCamera();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;outOfCamera()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector3&nbsp;viewPos&nbsp;=&nbsp;Camera.main.WorldToViewportPoint(transform.position);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(viewPos.x&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;Destroy(gameObject);&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <h3>Dodanie punktacji</h3>
        <p>Punktacja wyświetlana będzie na elemencie <i>UI</i> w tym celu dodajemy nowy <i>GameObject->UI->Text</i> zmieniamy jego nazwę na <i>Score</i> oraz dodajemy drugi text który nazywamy <i>MaxScore</i>. Obiekty te należy rozmieścić jak na załączonym obrazku.</p>
        <img src='images/flappy_coder_text.png' />
        <p>Do obiektu <i>Canvas</i> należy podpiąć skrypt <code>ScoreManager</code> jest to <i>singleton</i> co oznacza, że na scenie w danym momencie może znajdować się wyłącznie jedna instancja tej klasy i jest ona dostępna w każdym miejscu aplikacji. Skrypt ten będzie przechowywać aktualny wynik, aktualizować wyświetlany wynik i zapisywać maksymalny wynik.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine.UI;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;ScoreManager&nbsp;:&nbsp;MonoBehaviour&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="Modifier">static</span>&nbsp;ScoreManager&nbsp;instance&nbsp;=&nbsp;<span class="Keyword">null</span>;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;Text&nbsp;scoreText;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;Text&nbsp;maxScoreText;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">private</span>&nbsp;<span class="ValueType">int</span>&nbsp;maxScore&nbsp;=&nbsp;0;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">private</span>&nbsp;<span class="ValueType">int</span>&nbsp;score&nbsp;=&nbsp;0;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="InlineComment">//&nbsp;Use&nbsp;this&nbsp;for&nbsp;initialization</span><br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;Start&nbsp;()&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(instance&nbsp;==&nbsp;<span class="Keyword">null</span>)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;<span class="Keyword">this</span>;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="Statement">else</span>&nbsp;<span class="Statement">if</span>&nbsp;(instance&nbsp;!=&nbsp;<span class="Keyword">this</span>)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy(gameObject);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateMaxPoints();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">void</span>&nbsp;addScore(<span class="ValueType">int</span>&nbsp;points)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;score&nbsp;+=&nbsp;points;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scoreText.text&nbsp;=&nbsp;<span class="String">"Score:&nbsp;"</span>&nbsp;+&nbsp;score;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;updateMaxPoints();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">void</span>&nbsp;updateMaxPoints()<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxScore&nbsp;=&nbsp;PlayerPrefs.GetInt(<span class="String">"maxScore"</span>);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(maxScore&nbsp;&lt;&nbsp;score)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxScore&nbsp;=&nbsp;score;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlayerPrefs.SetInt(<span class="String">"maxScore"</span>,&nbsp;maxScore);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlayerPrefs.Save();<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;maxScoreText.text&nbsp;=&nbsp;<span class="String">"Max&nbsp;Score:&nbsp;"</span>&nbsp;+&nbsp;maxScore;<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <p>Do obiektu <i>Gap</i> dodajemy trzeci cube, któremu dajemy nazwę <i>Score</i>. <i>Cube</i> ten powinien znajdować się w punkcie: 0, 0, 0 oraz mieć skalę: 1, 20, 1. W inspektorze obiektu <i>Score</i> wyłączamy komponent <i>Mesh Renderer</i>. W komponencie <i>Box Collider</i> należy zaznaczyć opcję <i>Is Trigger</i>. Do obiektu <i>Score</i> należy dołączyć skrypt <code>Score</code> który będzie naliczać punkt za każdym razem gdy gracz wejdzie w trigger. Ostatnią rzeczą będzie zapisanie prefabrykantu, w tym celu należy zaznaczyć obiekt <i>Gap</i> oraz w inspektorze nacisnąć przycisk <i>Apply</i>.</p>
        <div class="code">
        <span class="Namespace">using</span>&nbsp;System.Collections;<br />
        <span class="Namespace">using</span>&nbsp;System.Collections.Generic;<br />
        <span class="Namespace">using</span>&nbsp;UnityEngine;<br />
        <br />
        <span class="Modifier">public</span>&nbsp;<span class="ReferenceType">class</span>&nbsp;Score&nbsp;:&nbsp;MonoBehaviour&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="Modifier">public</span>&nbsp;<span class="ValueType">int</span>&nbsp;points&nbsp;=&nbsp;1;<br />
        <br />
        &nbsp;&nbsp;&nbsp;&nbsp;<span class="ValueType">void</span>&nbsp;OnTriggerEnter(Collider&nbsp;other)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(other.tag&nbsp;==&nbsp;<span class="String">"Player"</span>)<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ScoreManager.instance.addScore(points);<br />
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
        &nbsp;&nbsp;&nbsp;&nbsp;}<br />
        }
        </div>
        <h3>Gotowa gra</h3>
        <div>
          <canvas class="emscripten center-block" id="canvas" oncontextmenu="event.preventDefault()" height="600px" width="960px"></canvas>
          <br>
          <div class="fullscreen pull-right"><img src="TemplateData/fullscreen.png" width="38" height="38" alt="Fullscreen" title="Fullscreen" onclick="SetFullscreen(1);" /></div>
          <div class="title pull-left">
            <div>FlappyCoder</div>
            <div><a href='https://github.com/noplisu/FlappyCoder'>Repozytorium</a></div>
          </div>
          <script type='text/javascript'>
            var Module = {
              TOTAL_MEMORY: 268435456,
              errorhandler: null,     // arguments: err, url, line. This function must return 'true' if the error is handled, otherwise 'false'
              compatibilitycheck: null,
              backgroundColor: "#222C36",
              splashStyle: "Light",
              dataUrl: "Release/WebGL.data",
              codeUrl: "Release/WebGL.js",
              asmUrl: "Release/WebGL.asm.js",
              memUrl: "Release/WebGL.mem",
            };
          </script>
          <script src="Release/UnityLoader.js"></script>
        </div>
      </article>
    </div>
  </body>
</html>